<!DOCTYPE html>
<html lang="en">

<head>
   <title>three.js webgl - geometry - cube</title>
   <meta charset="utf-8">
   <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
   <link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
   <script type="importmap">
         {
            "imports": {
               "three": "../build/three.module.js",
               "three/addons/": "./jsm/"
            }
         }
      </script>

   <script type="module">

      import * as THREE from 'three';

      let camera, scene, renderer;
      let mesh;
      let ufos = [];


      //숫자적 규칙이 안보이면 index규칙으로 접근할 수 있게 배열로 만든다!!!!!
      var arr_xzc = [
         {x: -20, z: -20, c: 0xFF0000},
         {x: 0, z: -20, c: 0xFF7903},
         {x: 20, z: -20, c: 0xffff00},

         {x: -20, z: 0, c: 0x05B94D},
         {x: 0, z: 0, c: 0x0000FF},
         {x: 20, z: 0, c: 0x000094},

         {x: -20, z: 20, c: 0xBC03FF},
         {x: 0, z: 20, c: 0xA3A3A4},
         {x: 20, z: 20, c: 0xFFFFFF}

      ]


      init();
      animate();

      function init() {

         camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
         camera.position.z = 100;
         camera.position.y = 20;

         scene = new THREE.Scene();

         const texture = new THREE.TextureLoader().load('textures/crate.gif');
         texture.colorSpace = THREE.SRGBColorSpace;

         const geometry = new THREE.CylinderGeometry(4, 8, 4, 30);

         for (var i = 0; i < arr_xzc.length; i++) {

            const material = new THREE.MeshBasicMaterial({color: arr_xzc[i].c, wireframe: true});
            mesh = new THREE.Mesh(geometry, material);
            mesh.position.x = arr_xzc[i].x;
            mesh.position.z = arr_xzc[i].z;
            scene.add(mesh);
            ufos.push(mesh);
         }

         console.log("mesh", mesh.position);

         renderer = new THREE.WebGLRenderer({antialias: true});
         renderer.setPixelRatio(window.devicePixelRatio);
         renderer.setSize(window.innerWidth, window.innerHeight);
         document.body.appendChild(renderer.domElement);


         window.addEventListener('resize', onWindowResize);

      }

      function onWindowResize() {

         camera.aspect = window.innerWidth / window.innerHeight;
         camera.updateProjectionMatrix();

         renderer.setSize(window.innerWidth, window.innerHeight);

      }

      var cnt = 0;
      function animate() {

         requestAnimationFrame(animate);   //재귀함수

         if(cnt > 100){
            ufos[0].rotation.y += 0.1;
            ufos[0].position.y += 0.1;
         }
         if(cnt > 200){
            ufos[1].rotation.y += 0.1;
            ufos[1].position.y += 0.1;
         }
         if(cnt > 300){
            ufos[2].rotation.y += 0.1;
            ufos[2].position.y += 0.1;
         }
         if(cnt > 400){
            ufos[3].rotation.y += 0.1;
            ufos[3].position.y += 0.1;
         }
         if(cnt > 500){
            ufos[4].rotation.y += 0.1;
            ufos[4].position.y += 0.1;
			camera.lookAt(ufos[4].position);
         }
         if(cnt > 600){
            ufos[5].rotation.y += 0.1;
            ufos[5].position.y += 0.1;
         }
         if(cnt > 700){
            ufos[6].rotation.y += 0.1;
            ufos[6].position.y += 0.1;
         }
         if(cnt > 800){
            ufos[7].rotation.y += 0.1;
            ufos[7].position.y += 0.1;
         }
         if(cnt > 900){
            ufos[8].rotation.y += 0.1;
            ufos[8].position.y += 0.1;
			
         }
         renderer.render(scene, camera);
         cnt++

      }

   </script>

</body>

</html>